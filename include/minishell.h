/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   minishell.h                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: nlouis <nlouis@student.hive.fi>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/12/31 10:27:36 by nlouis            #+#    #+#             */
/*   Updated: 2025/01/19 13:46:33 by nlouis           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef MINISHELL_H
# define MINISHELL_H

# include "libft.h"
# include <stdio.h>
# include <stdlib.h>
# include <stdbool.h>
# include <ctype.h>
# include <sys/types.h>
# include <sys/wait.h>
# include <sys/stat.h>
# include <fcntl.h>
# include <readline/readline.h>
# include <readline/history.h>
# include <errno.h>
# include <signal.h>
# include <unistd.h> // For chdir and getcwd
# include <string.h> // For strerror


# define BOLD_BLUE "\033[1;34m"
# define RED "\033[0;31m"
# define RESET "\033[0m"

# define MAX_TKS 1024

#define FILE_PERMISSIONS (S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)

// TOKENS
typedef enum e_tk_type
{
	TK_WORD,
	TK_PIPE,
	TK_REDIRECT_INPUT,
	TK_REDIRECT_OUTPUT,
	TK_APPEND_OUTPUT,
	TK_HEREDOC
}	t_tk_type;

typedef struct s_tk
{
	t_tk_type	type;
	char		*value;
}	t_tk;

// cmd
typedef struct s_cmd
{
	char			*name;           // cmd name (e.g., "cat")
	char			**args;             // cmd arguments (e.g., ["file.txt"])
	char			*input_redirect;    // Input redirection file (e.g., "input.txt")
	char			*output_redirect;   // Output redirection file (e.g., "output.txt")
	char			*heredoc_delimiter; // Heredoc delimiter (e.g., "EOF")
	int				append;             // Append mode for output redirection
	int				builtin;
	char			*path;
	struct s_cmd	*pipe_to;           // Next cmd in pipeline
}	t_cmd;

// CENTRALIZED MINISHELL STRUCT
typedef struct s_ms
{
	char		**envp;			// Copy of environment variables
	int			exit_status;	// Last exit status
	const char	*input;			// Original user input
	t_tk		**tks;		// tks generated by lexer
	t_cmd		*cmd;		// Parsed cmd structure
}	t_ms;

void	free_cmd(t_cmd *cmd);
void	free_tks(t_tk **tks);
void	free_all(t_ms *ms);

t_tk	**lexical_analyser(t_ms *ms, const char *input);

t_cmd	*parse_tks(t_ms *ms, t_tk **tks);

bool	validate_cmds(t_ms *ms, t_cmd *cmd, char **envp);

void	set_signals_noninteractive(void);

int		setup_redirections(t_cmd *cmd);



void	set_signals_interactive(void);

void	reset_prompt(t_ms *ms);
void	exit_program(t_ms *ms);
void	syn_err(t_ms *ms, char *error_message);
void	cmd_err(char *error_message);
void	error(t_ms *ms, char *error_message);

void	print_cmd(t_cmd *cmd, int indent);
void	print_tks(t_tk **tks);

/* Prototypes for utility functions */
bool    is_valid_identifier(const char *name);       // For validating identifiers
int     find_env_variable(t_ms *ms, const char *var, size_t var_len);
void    add_new_env_variable(t_ms *ms, const char *var);
void    add_or_update_env(t_ms *ms, const char *var);

/* Prototypes for processing */
void    process_env_var_with_equal(t_ms *ms, const char *arg);   // Handles variables with '='
void    process_valid_identifier(t_ms *ms, const char *arg);    // Handles valid identifiers

/*Built in cmd*/
void	execute_external_cmd(t_ms *ms, t_cmd *cmd);
void	execute_cmd(t_ms *ms, t_cmd *cmd);
void	execute_builtin_cmd(t_ms *ms, t_cmd *cmd);

/* execute cmd */
int		setup_pipe_redirection(int prev_fd, int next_fd);
char	**setup_argv(t_ms *ms, t_cmd *cmd);
void	child_process(t_ms *ms, int prev_fd, int next_fd, t_cmd *cmd);
void	parent_process(t_ms *ms, pid_t pid, int *fd, int *prev_fd);
void	handle_pipe(t_ms *ms, t_cmd *cmd, int *fd, int *next_fd);

/* Builtin export */
char	*ft_strcpy(char *dst, const char *src);
void	execute_builtin_cmd(t_ms *ms, t_cmd *cmd);
void	builtin_echo(t_ms *ms, t_cmd *cmd);
void	builtin_cd(t_ms *ms, t_cmd *cmd);
void	builtin_pwd(t_ms *ms);
void    builtin_export(t_ms *ms, t_cmd *cmd);// double check maybe not work
void    print_env(t_ms *ms);  
void	builtin_unset(t_ms *ms, t_cmd *cmd);
void	builtin_env(t_ms *ms);
void	builtin_exit(t_ms *ms, t_cmd *cmd);



#endif
